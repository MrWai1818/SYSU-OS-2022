<font size =6>**操作系统原理 实验二**</font>

## 个人信息

【院系】计算机学院

【专业】计算机科学与技术

【学号】20337172

【姓名】蔡嘉威
  

## 实验题目

计算机开机启动及中断调用

## 实验目的

1. 熟悉计算机开机过程并编写代码。
1. 熟悉操作系统中断机制，通过汇编语言进行实现。
2. 掌握基础汇编语言，可以使用汇编语言写简单的程序。
3. 掌握处理器寻址方式。
4. 掌握常用的寄存器用法。
5. 熟练掌握qemu+gdb调试方法。

## 实验方案

  首先对计算机的启动进行学习，了解Boot In/Out System，以及Master boot record为从0x7c00往后512字节，其最后两位需为0xaa55。
  再对实模式的中断学习后在进行实验：
  ><img src="img/0.png">
### assignment1 :
  通过学习README.md中的Example内容，将代码编译成bin后通过:
  >qemu-img create hw.img 10m
  
  生成一个大小为10m名为hw的镜像文件，再通过linux的拷贝指令dd：
  >dd if=mbr.bin of=hw.img bs=512 count=1 seek=0 conv=notrunc

  将mbr.bin文件内容写入镜像。
  通过查询颜色表对Example内容进行替换。
  经过进一步学习，更新如下代码来完成1.2的内容：
  ><img src="img/1.4.png">
  其中运算通过函数
  >显存起始位置 = 0xB8000 + 2 ⋅ (80 ⋅ x + y)

  确定字符显示的位置

### assignment2:

- **2.1** 经过学习10h中断，了解到02h的功能为设置光标位置，03h是获取当前光标位置，09h是在光标处输出字符；以及16h中断，00h是对键盘的读入。对2.1题目进行解读，将“利用中断实现光标的位置获取和光标的移动”理解为:**可以通过键盘输入移动光标**,欲经如下代码实现：
  ><img src="img/2.1.png">

  完整代码还有3个和left函数相仿的函数，分别为right、up、down，通过16h中断00h识别键盘上下左右键，改变光标位置。
- **2.2** 通过10h中断9h可以在光标位置输出字符，但是对于字符串输出，若使用09h，代码会过于冗长，便通过学习10h中断13h进行字符串输出，有代码如下：
  ><img src="img/2.2.png">

  经过学习，对各个寄存器以及相关语句的作用已在注释中有所体现，便不再赘述。

- **2.3**
  探索实模式的键盘中断后，利用键盘中断16h中的00h了解键盘输入，在对2.1实验进行改进，新增加函数get，使用中断10h的09h输出已经读入的字符，代码如下：
    ><img src="img/2.3.png">

  经过10h中断3h和2h内容，在输出字符后对光标位置进行改变。
  get函数之后便是2.1中的left函数，对各个寄存器以及相关语句的作用已在注释中有所体现，便不再赘述。

### assignment3:
  - **3.1**
  经过对汇编的学习和观察班级群同学们以及老师的交流，阅读test.cpp的代码了解实验目的后实现分支逻辑如下：
    ><img src="img/3.1.png">
  - **3.2**
    通过**基址变址寻址和基址寻址**以及call指令调用c函数，完成3.2代码转化：
    ><img src="img/3.2.png">
  - **3.3**
    通过对**基址变址寻址和基址寻址**以及call指令调用c函数、栈指令的学习完成3.3代码转化：
    ><img src="img/3.3.png">
  对各个寄存器以及相关语句的作用已在注释中有所体现，便不再赘述。

### assignment4:
  经过对实模式下的中断的进一步学习，了解了10h中断02h、03h、09h的详细使用。并借助1ah时钟中断0h取得随机时间值并进行对应计算得到随机数，进行程序的**变色**。借助15h盒式磁带中断86h的延迟功能进行输出字符的**延时**。最后使用栈临时计算存储光标的对称点，以此进行**双向弹射**。代码如下：
  > <img src="img/4.1.png">
  ><img src="img/4.2.png">
  ><img src="img/4.3.png">
  - 为源变址寄存器重新赋值，以达到循环输出的功能
  - 其他打印字符函数和循环赋值函数均与dright和outdr类似，便不再赘述
  ><img src="img/4.4.png">
  - 延时函数中cx，dx用于存储延迟时间
  ><img src="img/4.5.png">
  - 双向输出先将旧的光标数据压入栈，在通过运算得到对称点的光标，并通过10h中断2h设置对称光标并进行打印，之后将旧的光标输出压出栈，覆盖临时计算得出的对称光标以进行下一个点的打印。
  
对各个寄存器以及相关语句的作用已在注释中有所体现，便不再赘述。

### assignment5:
  assignment5是对assignment1、assignment2以及assignment4的提炼与整合。主要还是进行了美化：
  > <img src="img/5.2.png">
  - 对界面进行颜色改变以及装饰
  > <img src="img/5.1.png">
  - 在画面中央进行字符串打印
  - 通过16h中断的00h读入任意字符就进行界面转跳
  - 界面转跳就是进行旧界面清空
  - second之后的代码即为assignment4的代码，便不再赘述。
## 实验过程

### assignment1 :
  使用-s，-S使用gdb进行程序调用：
  ><img src="img/1.1.png">

  通过1234端口将gdb与qemu中运行程序链接，输入info r显示寄存器信息，p+地址打印地址值，x/10i +地址显示所提及地址之后十条指令，结果如下：
  ><img src="img/1.2.png">
  1.1结果如下：
  > <img src="img/r1.1.png">
  通过改动打印的物理地址形成如下1.2的v字输出：
  ><img src="img/r1.2.png">

### assignment2 :
  - **2.1**
    在理解题意时花了大量时间，最终决定以按动键盘方向键来移动光标位置来实现，初始位置如下：
    ><img src="img/r2.1.png">
    经过按动 **'下左下右'** 键后结果如下：
    ><img src="img/r2.2.png">
  - **2.2**  
    ><img src="img/r2.3.png">
  - **2.3**
    ><img src="img/r2.4.png">
  
    ####  因为截图难以显示功能，详情请看assignment2.mp4

### assignment3 :
  结果截图：
  ><img src="img/r3.png">
  - **遇到问题并解决：**
    1.在给寄存器赋值时，会不注意位数的差异而出错，如eax用bx赋值。
    2.在取字时会混用byte、word、dword，通过多次尝试了解，byte是取单字节，word取双字节，dword取四字节，而在[address]前不加则是根据所要移动的寄存器的位数决定。

### assignment4 :
  截图：
  ><img src="img/r4.png">
  #### 因截图完全展现，详情请查看assignment5.mp4

### assignment5 ：
  截图：
  ><img src="img/r5.1.png">
  ><img src="img/r5.2.png">

  #### 因截图完全展现，详情请查看assignment5.mp4
  - **遭遇问题及解决**：
    1.在设置字符串以及相关函数时，未使用数据块来声明，而是直接在代码开头声明，导致声明之后的实现代码仅部分生效。通过反汇编代码查看后，发现全部代码都被设定为数据区，便将定义全部转移至代码末尾，至此问题解决。
      ><img src="img/w1.png">
    2.在做双向弹射时，纠结于实现从(2,79)射出，思考许久为得出答案，后来想到双向射出即是对称射出，从(23，79)射出，便编写了临时计算对称光标的代码，至此问题解决。



## 实验总结


本次实验旨在熟悉计算机的开机过程、操作系统实模式中断功能的使用，以及汇编语言的语法。关于计算机的启动，因为计算机的启动非常矛盾，类似于先有鸡还是先有蛋的问题，即计算机要想启动，必须先启动程序，但是事实上计算机不启动又无法运行程序。因此为解决这个问题，工程师把启动程序的一小段存在内存中，也就是BIOS，在经过硬件自检(POST)后，BIOS会按照启动顺序(Boot Sequence)将控制权交给大小只有512字节，末尾两位为0xaa55的主引导记录(MBR)。经过存在MBR里的分区表和调用操作系统的机器码，将控制权转到对应分区找到的操作系统程序。而MBR所存在的位置:0x7c00是一个历史遗留问题，是从1981年IBM公司的最早个人电脑IBM PC 5150中开始的，因为当时内存最小32kb，取值范围0x0000~0x7fff，而8088芯片和mbr以及调用mbr记录需要占用1024+512+512的内存，而0x7fff-512-512+1也就得到了0x7c00。

关于此次实验，更多的感觉是针对操作系统实模式中断的使用，以及MBR的概念悉知以及创建，还有对汇编语言的熟悉与了解。事实上个人感觉对于gdb调试的涉及方便并不多，也许是因为自己的编码习惯，导致难以直接看出的错误较少。此次assignment5的代码量为265行，仅仅只是完成字符串输出、页面切换以及字符串弹射的实现，也说明代码也许还有许多地方有精简的空间，相比于热身小实验的代码量而言。当然，也只有在实验完成后，有了一定的知识储备，再回去看热身小实验的代码，自己才能看的明白大概。


## 参考文献
[计算机是如何启动的](https://www.ruanyifeng.com/blog/2013/02/booting.html)
[为什么主引导记录的内存地址是0x7C00](https://www.ruanyifeng.com/blog/2015/09/0x7c00.html)
[Why BIOS loads MBR into 0x7C00 in x86 ?](https://www.glamenv-septzen.net/en/view/6)
[x86架构：实模式下的中断](https://www.cnblogs.com/theseventhson/p/13068709.html)
[显示字符串_字符串中断方式](https://www.cnblogs.com/mlzrq/p/10223039.html)
[汇编语言实现简易文本编辑器](https://blog.csdn.net/guozuofeng/article/details/102640891)
[汇编产生随机数](https://blog.csdn.net/lilang66/article/details/7408727)